- clipping window
	- 真实世界里可见范围
	- Opengl：glOrtho(left,right,bottom,top,-1,1)
- viewpoint
	- 显示窗口，将clipping window的内容投影进view point（放缩）
	- glViewport(x,y,width,height)
- 定义相机参数
	- glCamer...(posX,posY,posZ,atX,atY,atZ,upX,upY,upZ)
		- pos:相机位置
		- at：相机视线指向位置【】-
		- up：和pos一起确定相机倾斜角
## 视频显示设备

#### 刷新式阴极射线显像管CRT（Refresh Cathode-Ray Tubes）

从电子枪中发射电子束，经过若干部件后将荧光粉图层的特定点点亮，并根据刷新率定时发送电子束（否则，被点亮的图层位置会迅速消失）。主要构造如下：

- a high positive voltage：正电极，用于加速电子束
- a high negative voltage：负电极，用于减少通过的电子数量，以控制到达荧光粉图层的电子数量，进而绘制出特定的亮度或光照强度
- the focusing system：聚焦系统，用于将电子集中，降低电子束的半径，有电场、磁场两种形式（使用磁场可以得到更小的半径）
- defletion：偏移，使用水平和竖直两组线圈，分别控制电子束在横向和纵向的偏移距离，以到达不同的屏幕位置
- collide：碰撞，电子束在经过上述系列操作后终于到达荧光粉图层，发生碰撞，其部分能量转化为热能消散掉，剩余能量使其变成了更高的量子能状态（激发量子态），并在一定时间后恢复正常状态，同时发射光子——**光线的频率（即颜色）与激发量子态和正常状态之间的能量差异成正比**

CRT中有许多不同的荧光粉图层，其主要区别是它们的持久性（persistence）——所有的激发量子态电子恢复原始状态所消耗的时间，通常用其光强回落到当前期望值的1/10来表示。

发射到某一点的电子束所点亮的区域亮度从其中心位置到边缘服从高斯分布。因此相邻两点的交叉处要求光线强度已经下降到60%以下，否则会发生色彩重叠。在不发生色彩重叠的情况下一个CRT所能展示的最多的点的数目称为**分辨率**（resolution）。

#### 光栅扫描显示器（Raster-Scan Displays）  
是CRT最常用的图形显示器，将每一像素的信息存储在帧缓存中。  
缓存的**深度**定义为每一像素中存储信息的字节数。字节数为1——位图文件（bitmap），为二值文件；字节数大于1——像素映射（pixmap），为多彩模式  
通常是按照行列依次扫描，并根据刷新频率进行更新

#### 随机扫描显示器（Random-Scan Displays）  
只绘制屏幕上有图像的部分（如某点到某点的一条线段），无法绘制真实渲染的场景

#### 彩色CRT显示器  
方式一：射束穿透（beam-penetration），设置若干层不同颜色的荧光粉图层，使用不同速度的电子去**不同的图层，可显示的颜色很少  
方式二：遮罩（shadow-mask），通过带孔洞的遮罩将RGB三种颜色的光打到同一目标位置，通过颜色混合显示不同的效果。  
全彩/真彩——每一像素存储24位字节的图像系统（即R、G、B各占8位）

#### 平板显示器（Flat-Panel Displays）  
比CRT更加轻薄，可分为发射型（将电能转化为光能）、非发射型（使用光学效应将太阳光或其他光转化成图像）两类。主要类型如下：

- 等离子面板（Plasma panels）：发射型，在两块玻璃板（上面分别放置水平、竖直的导体）中充入混合气体，通过导体控制气体形成电子和离子
- 薄膜电致发光显示器（thin-film electroluminescent displays）：发射型，将等离子面板中间填充的混合气体更换为荧光粉图层
- 发光二极管（light-emitting diode, LED）：发射型，按照像素矩阵排列若干发光二极管
- 液晶显示屏（liquid-crystal display, LCD）：非发射型，通过控制液晶来控制光线通过时是否发生偏转，从而控制该束光线是否会顺利通过，可分为被动/主动两种

#### 三维显示设备（Three-Demensional Viewing Devices）  
可根据物体距相机的距离进行不同的显示，可用于医学扫描、地震预测等方面

#### 立体与虚拟现实系统（Stereoscopic and Virtual-Reality Systems）  
在人的左右眼位置分别放置不同的图像，显示的是从该位置到场景的角度上所看到的影像。有两种形式：

- 佩戴特殊设备（如，眼镜），根据位置、旋转等信息显示相应图像
- 使用显示设备在三维世界中投影物体

## 光栅扫描系统raster-scan system

可以在系统内存中开辟一个专门区域，用于图形显示的处理和帧缓冲的存取。存取时按照该像素点在笛卡尔坐标系中的坐标读取信息，video controller读取这些信息湿气显示到屏幕上
- diaplay processor:将表述的图形转换为每个像素的颜色信息

## 图形工作站和显示系统

在实际应用中，除了传统的显示设备，还有如下几种：

- 多屏显示器：可用于同时显示多个场景或某个场景的多个角度，可用于监控、手术等
- 曲面显示器：可以使不同方向的人都可以看到屏幕上的内容
- 控制中心：通过显示屏和操作杆（或触摸屏）的组合，来完成某一系统的各项控制功能

## 输入设备

- 键盘：除了传统的字母键盘，还可以附加数字、旋转等其他按键功能
- 鼠标
- 轨迹球（二维）、空间球（三维）：其中空间球并不真正移动，而是根据其各个维度所感受到的压力进行位置控制
- 控制杆：也可分为实际移动、压力控制两种方式
- 数据手套：多用于虚拟现实系统中
- 数字转换器：将屏幕输入转化为一系列离散的坐标点信息，应用如触摸屏、点读机
- 图像扫描
- 触摸屏：光学触摸屏——使用LED技术；电子触摸屏——使用两个有微小间距的平板
- 光笔：应用较少
- 声音系统：音控

## 硬拷贝设备

即打印技术，可分为两类：  
- 击打式（impact）打印机：使用点阵打印头，按照像素进行打印  
- 非击打式（nonimpact）打印机：如激光、喷墨、静电、热敏等
## 坐标表示coordinate representation

将放置好的物体显示在屏幕上要经历一系列复杂的步骤，进行若干次的坐标变换。主要步骤如下：

1. 模型坐标空间：在其中设定好各个零部件内部的位置信息
2. 世界坐标空间：将模型放置在世界中
3. 观察坐标空间：将观察者（摄像机）位置设为原点，观察方向为正方向的坐标系中的顶点位置
4. 标准坐标空间：将三维坐标转化为二维坐标，并归一化至0~1或-1~1，使其不受不同分辨率、纵横比的显示设备所影响
5. 屏幕坐标空间：根据具体的屏幕设置将其转化为对应的像素位置信息

## 图形函数

一个图形包中有许多不同的功能，可以将其分类如下：

- 基础的图形(图元）输出：点、直线、曲线、球、圆柱等等的绘制
- 属性：用于控制如何绘制基础图形，如颜色、线型、填充方式等
- 几何变换：大小、位置、旋转
- 模型变换：通常会提供针对复杂模型的构建功能，即使用树形结构将模型的各个零部件进行连接
- 显示变换：将图形显示到输出设备上，如更改场景视图、投射方式、相机位置、光照等
- 输入函数：控制输入
- 控制操作：如清空屏幕、初始化参数等

## 软件标准

为了保证在某一硬件设备上使用图形包所完成的工作在其他硬件上的可移植性，需要制定具体的标准。目前存在过的标准如下：

- Graphical Kernal System（GKS）：第一个图形软件标准，主要为二维
- Programmer’s Hierarchical Interactive Graphic System（PHIGS）：GKS的扩展
- PHIGS+：增加了三维渲染
- Graphics Library（GL）：主要为快速的实时渲染所设计
- OpenGL：三维为主，当z=0时可表示二维，是当前最流行的图形软件包

## 其它图形包

这里简单列举，不做具体介绍：  
Open Inventor、Virtual-Reality Modeling Language（VRML）、Java 2D、Java 3D、RenderMan Interface

## OpenGL介绍

### 基础语法

- 基本库：gl开头，接下来的单词第一个字母大写，如glBegin，glClear，glCopyPixels，glPolygonMode等
- 符号常量：GL开头，接下划线和大写字母，如GL_2D，GL_RGB，GL_CCW，GL_POLYGON，GL_AMBIENT_AND_DIFFUSE等
- 特殊数据类型：GL开头，接小写单词，如GLbyte，GLshort，GLint，GLfloat，GLdouble，GLboolean等

**函数的参数会使用指向数组的指针来完成调用。**

### 相关库

- OpenGL Utility（GLU）：函数名称以glu开头，主要包括视口设置、投影矩阵、复杂物体近似、表面渲染等复杂操作
- Open Inventor：一些预定义的复杂物体形状和三维应用
- OpenGL Utility Toolkit（GLUT）：函数名称以glut开头，提供了与各类不同系统（Windows，Apple等等）屏幕显示系统的接口。

### 头文件

通常可以使用  
`#include<GL/glut.h>`或`#include<GLUT/glut.h>`  
直接代替以下的复杂头文件：

```c++
    #include<windows.h>
    #include<GL/gl.h>
    #include<GL/glu.h>
```

### 使用GLUT进行Windows窗口展示

- 初始化GLUT：glutInit(&argc, argv);
- 创建窗口并赋名：glutCreateWindow(“An Example OpenGL Program”);——参数为该窗口的标题栏名称
- 创建图片：glutDisplayFunc(lineSegment);——这里的参数是一个在其他位置定义好的函数，通过调用绘制函数中所提供的操作
- 完成创建过程：glutMainLoop();——必须放在代码的最后，进入GLUT事件处理循环，让所有的与“事件”有关的函数调用无限循环，同时等待输入
- 设置窗口位置：glutInitWindowPosition(50, 100);——以屏幕的左上角为原点，以像素为单位
- 设置窗口大小：glutInitWindowSize(400, 300);——窗口的长度、宽度，单位为像素
- 设置显示模式：glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);——这里的两个参数为默认参数

### 一个完整的OpenGL程序

- 选择背景颜色：glClearColor(1.0, 1.0, 1.0, 0.0);——分别代表RGBA的值，这里为白色，该函数并没有把显示窗口放到屏幕上，而是使用该颜色值清空了缓存区，要想从缓存中将该函数的值读取到屏幕中，需要调用函数glClear(GL_COLOR_BUFFER_BIT);——该函数的参数是代表颜色缓存中的比特值的常量
- 设置颜色：glColor3f(0.0, 0.4, 0.2);——其中“3”和“f”都是可选参数，所设置的颜色对下面的代码都管用，后出现的glColor3f颜色会覆盖前面的glColor3f对再接下来的代码产生作用
- 使用二维场景所需的操作：glMatrixMode(GL_PROJECTION); gluOrtho2D(0.0, 200.0, 0.0, 150.0);——窗口大小即位置为（从左下角开始）x轴0-200，y轴0-150，该范围外的图像不会显示
- 绘制图像的过程：  
    glBegin(GL_LINES);  
    …glVertex2i(180, 15);——左下角为原点  
    …glVertex2i(10, 145);  
    glEnd();
- 使所有OpenGL函数开始运行：glFlush();——强制刷新缓冲，保证绘图命令将被执行，而不是存储在缓冲区中等待其他的OpenGL命令

下面是一个完整的OpenGL例子：

```c++
#include <GL/glut.h>      //or others

void init(void)
{
    glClearColor(1.0, 1.0, 1.0, 0.0);    //Set diplay-window color to white

    glMatrixMode(GL_PROJECTION);    //Set projection parameters
    gluOrtho2D(0.0, 200.0, 0.0, 150.0);
}

void lineSegment(void)
{
    glClear(GL_COLOR_BUFFER_BIT);    //Clear display window

    glColor3f(0.0, 0.4, 0.2);    //Set line segment color to green
    glBegin(GL_LINES);
        glVertex2i(180, 15);    //Specify line-segment geometry
        glVertex2i(10, 145);
    glEnd();

    glFlush();    //Process all OpenGL routines as quickly as possible
}

void main(int argc, char** argv)
{
    glutInit(&argc, argv);    //Initialize GLUT
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);    //Set display mode
    glutInitWindowPosition(50, 100);    //Set top-left display-window position
    glutINitWindowSize(400, 300);    //Set display-window width and height
    glutCreateWindow("An Example OpenGL Program")    //Create display window

    init();    //Execute initialization procedure
    glutDisplayFunc(lineSegment);    //Send graphics to display window
    glutMainLoop();    //Display everything and wait
}
```

### OpenGL中的错误处理

推荐在每个程序中都加入一个通用的错误报告函数，如：

```c++
#include <stdio.h>

GLenum erorCheck()
{
    glenum code;
    const GLubyte *string;

    code = glGetError();
    if(code != GL_NO_ERROR)
    {
        string = gluErrorString(code);
        fprintf(stderr, "OpenGL error: %s\n", string);
    }

    return code;
}
```
  ## 坐标系

对物体的描述一般包括其位置、颜色、包围盒（每个坐标轴方向上的最小值和最大值）等

#### 屏幕坐标系

通常以屏幕左上角为原点

- 设置像素点颜色：setPixel(x, y, color);
- 获取像素点颜色：getPIxel(x, y);

有时会有第三维的坐标值，用来表示物体的深度

#### 绝对坐标和相对坐标

前面所说的坐标表示方法都是绝对坐标，即相对于原点的坐标。在某些时候也可使用相对坐标来表示物体，即每一点使用其相对于上一点的位移来表示

## 在OpenGL中建立二维世界坐标

直接使用上一章中所介绍的函数即可：

```c++
glMarixMode(GL_PROJECTION);
glLoadIdentity();
gluOrtho2D(xmin, xmax, ymin, ymax);
```

## OpenGL的点绘制函数

在绘制函数中选择参数GL_POINTS，点的坐标数据类型可选i（integer），s（short），f（float），d（double），如果使用向量，还可以在后面加上v（vertex）。下面是几个例子：

```c++
	gin(GL_POINTS):
    glVertex2i(50, 100);
    glVertex2i(75, 150);
    glVertex2i(100, 200);
glEnd();
```

其中的点坐标也可以单独定义，即：

```
int point1[] = {50, 100};
int point2[] = {75, 150};
int point3[] = {100, 200};

glBegin(GL_POINTS);
    glVertex2iv(point1);
    glVertex2iv(point2);
    glVertex2iv(point3);
glEnd();
```

还可以使用float等类型或者自定义类型的坐标点。

## OpenGL的直线绘制函数

直线绘制根据参数不同可以分为下面三类：

- GL_LINES：在点序列中两两组队，分别连线，多余的点忽略，如下面的代码块就会绘制1-2，3-4两条线段

```
glBegin(GL_LINES);
    glVertex2iv(p1);
    glVertex2iv(p2);
    glVertex2iv(p3);
    glVertex2iv(p4);
    glVertex2iv(p5);
glEnd();
```

- GL_LINE_STRIP：点序列依次连接，收尾不连接，如下面的代码块会绘制1-2，2-3，3-4，4-5四条线段

```
glBegin(GL_LINE_STRIP);
    glVertex2iv(p1);
    glVertex2iv(p2);
    glVertex2iv(p3);
    glVertex2iv(p4);
    glVertex2iv(p5);
glEnd();
```

- GL_LINE_LOOP：点序列依次连接，且末尾点连接到开头点，如下面的代码块会绘制1-2，2-3，3-4，4-5，5-1五条线段

```
glBegin(GL_LINE_LOOP);
    glVertex2iv(p1);
    glVertex2iv(p2);
    glVertex2iv(p3);
    glVertex2iv(p4);
    glVertex2iv(p5);
glEnd();
```

## OpenGL的曲线绘制函数

这里没有细讲，以后再补充

## 区域填充图元

通常在上色前要将物体以多边形网格的形式表示。

## 多面体填充

首先给出一个标准多边形的定义：所有顶点都在同一平面内，各边没有交叉，闭合。若有部分点不在同一平面内，可以将其进行切割。

#### 多边形分类

- **凸多边形**（convex polygon）：所有内角≤180°；其内部点位于任意一条边的同一侧；在内部任选两点，其连线不会穿过其边界。
- **凹多边形**（concave polygon）：至少一个内角＞180°；至少存在一条边的两侧都有其内部点；在内部任选两点的连线可能会穿过其边界。
- **退化多边形**（degenerate polygon）：有一些点共线或重复的多边形，或顶点数＜3的多边形。
    
    ```
    OpenGL中需要所有的多边形为凸
    ```
    

#### 辨认凹多边形

- **边界向量叉积法**：计算每相邻两个边界向量的叉积，若全部为同一符号，则为凸多边形；否则为凹多边形。

#### 切割凹多边形

- 方法一：首先计算多边形每条边的向量，及其**相邻两边的叉积**，所得叉积的第三维z的值若全为正，则是凸多边形，无需切割；若有z的值为负，则可以沿着这两条边中的一条，对该凹多边形进行切割。切割后重复上述步骤直至子图形全部为凸多边形。
- 方法二：**旋转法**。依次将多边形的点放置在原点位置，并将该点的下一点放置在X轴方向上，若下一点的再下一点位于x轴下方，则该多边形为凹多边形，可以沿X轴进行切割；否则，依次更换原点位置的顶点，重复上述步骤。

#### 多边形切割为一系列三角形

- **凸多边形**：任取三个连续顶点作为第一个三角形，然后从顶点序列中去除第二个顶点，再重复上述步骤，直至顶点序列中只余最后三个顶点。
- **凹多边形**：在进行与凸多边形相同操作的同时，要注意每次选择的三个点中，第一个点与第三个点的连线必须在多边形内部。

#### 内部-外部测试

首先介绍内部-外部测试的两种常用方法，注意当图形较为复杂（尤其是各边发生交叉时），两种法则所得的结果可能不同：  
- **奇数-偶数法则**（Odd-Even Rule）：从待测试点到图形外部遥远的一点画线，记录所画线通过的图形边数量。若为奇数，则该点在图形内部；若为偶数，则该点在图形外部。  
- **非零环绕数法则**（Nonzero Winding-Number Rule）：从待测试点到图形外部遥远的一点画线，并将环绕数初始化为0。每通过一条图形边时，判断该图形边的方向。若从右向左，则环绕数加一；若从左向右，则环绕数减一。判断最终的环绕数值，若不为0，则该点在图形内部；若为0，则该点在图形外部。

非零环绕数法则的一些计算方法：  
- **叉积法**：待测试点到图形外部遥远的一点设为向量u，经过的图形边为向量E，求u×E，结果为正，则边界方向为从右到左，环绕数加一；否则，减一。  
- **点积法**：求向量u的法线，方向为从P向远点望方向的从右向左，即若 u=(ux,uy)，则法线=(−uy,ux)。求该法线与向量的点积，结果为正，则边的方向从右向左，环绕数加一；否则，减一。

通过环绕数可以得到一些特殊的区域，如：  
- 两个逆时针环绕的图形的交集：环绕数＞1的部分  
- A-B：设有逆时针A和顺时针B，则A-B=环绕数为正的部分

#### 多边形表

多边形表通常由两部分组成：  
- **几何表**（geometric tables）：定义其空间位置和旋转信息。一般包括三个列表——顶点列表、边列表、表面列表。其中顶点列表、边列表可以省略，但是会影响运行效率。还可以在边列表中加入其所在的表面信息。或是加入每条边的斜率、包围盒等等。  
- **属性表**（attribute tables）：如透明度、材质信息等。

#### 平面等式

一般式：Ax+By+Cz+D=0  
如果所给点不在同一平面内，可以采取一定的方法进行近似，如：  
- 为每个子平面计算一般式，并取其A、B、C、D各自的平均值作为近似平面的参数值。  
- 将物体分别投影到各个坐标平面上，并利用yz平面求得A值，xz平面求得B值，xy平面求得C值，最后带入适当点求得D值（**_D的求法没有写，猜测是这样_**）。

#### 多边形的前后表面

- **前表面**（front face）：可见的、外部的，在平面的一般式中，Ax+By+Cz+D＞0（右手坐标系，平面在从前向后的方向上看是逆时针表示的）
- **后表面**（back face）：面向物体内部，在平面的一般式中，Ax+By+Cz+D＜0

平面的旋转可用**法向量**（normal vector）表示，平面Ax+By+Cz+D=0的法向量为（A,B,C）。也可以使用平面向量求得法向量，即N=(V2−V1)×(V3−V1)。求得法向量后，可由法向量和平面上一点的点积求得平面一般式中的参数D，即N⋅P=−D

## OpenGL的多边形填充函数

```
这里要注意，绘制“外部”表面时必须按照逆时针方向定义顶点。
```

首先介绍矩形绘制函数：

```
glRect*(x1, y1, x2, y2);
```

这里的*与前面类似，可用i、s、f、d替换，也可在后面加v代表用向量作为参数。生成的矩阵以(x1,y1),(x2,y1),(x2,y2),(x1,y2)为顶点顺序。  
下面介绍使用glBegin();和glEnd();函数构建多边形的方法，根据参数不同会产生不同的效果如下：

- GL_POLYGON：按照所给的顶点序列依次绘制多边形顶点，如下面的代码块会生成1-2-3-4-5-6-1的多边形：

```c
glBegin(GL_POLYGON);
    glVertex2iv(p1);
    glVertex2iv(p2);
    glVertex2iv(p3);
    glVertex2iv(p4);
    glVertex2iv(p5);
    glVertex2iv(p6);
glEnd();
```

- GL_TRIANGLES：按照所给的顶点序列每三个一组依次绘制三角形顶点，多余顶点会被忽略，如下面的代码块会生成1-2-6，3-4-5两个三角形：

```c
glBegin(GL_TRIANGLES);
    glVertex2iv(p1);
    glVertex2iv(p2);
    glVertex2iv(p6);
    glVertex2iv(p3);
    glVertex2iv(p4);
    glVertex2iv(p5);
glEnd();
```

- GL_TRIANGLE_STRIP：按照所给的顶点序列依次绘制多边形顶点及其中的三角形，相邻三角形共用一条边，如下面的代码块会生成1-2-6，2-3-6，6-3-5，3-4-5四个三角形组成的多边形。若顶点数=N，则会生成N-2个三角形，设当前三角形个数为n，当n为奇数时，三角形序列为n,n+1,n+2；当n为偶数时，三角形序列为n+1,n,n+2：

```c
glBegin(GL_TRIANGLE_STRIP);
    glVertex2iv(p1);
    glVertex2iv(p2);
    glVertex2iv(p6);
    glVertex2iv(p3);
    glVertex2iv(p5);
    glVertex2iv(p4);
glEnd();
```

- GL_TRIANGLE_FAN：按照所给的顶点序列依次绘制多边形顶点及其中的三角形，所有三角形共用一个顶点，如下面的代码块会生成1-2-3，1-3-4，1-4-5，1-5-6四个三角形组成的多边形。若顶点数=N，则会生成N-2个三角形，设当前三角形个数为n，则三角形序列为1,n+1,n+2：

```
glBegin(GL_TRIANGLE_FAN);
    glVertex2iv(p1);
    glVertex2iv(p2);
    glVertex2iv(p3);
    glVertex2iv(p4);
    glVertex2iv(p5);
    glVertex2iv(p6);
glEnd();
```

- GL_QUADS：按照所给的顶点序列每四个一组依次绘制四边形顶点，多余顶点会被忽略，如下面的代码块会生成1-2-3-4，5-6-7-8两个四边形：

```
glBegin(GL_QUADS);
    glVertex2iv(p1);
    glVertex2iv(p2);
    glVertex2iv(p3);
    glVertex2iv(p4);
    glVertex2iv(p5);
    glVertex2iv(p6);
    glVertex2iv(p7);
    glVertex2iv(p8);
glEnd();
```

- GL_QUADS_STRIP：按照所给的顶点序列依次绘制多边形顶点及其中的四边形，相邻四边形共用一条边，如下面的代码块会生成1-2-6，2-3-6，6-3-5，3-4-5四个三角形组成的多边形。若顶点数=N，则会生成N2−1个四边形，多余顶点会被忽略（**_书上写4的倍数的额外顶点会被忽略，为什么不是偶数的额外顶点被忽略？_**）设当前四边形个数为n，则四边形序列为2n-1,2n,2n+2,2n+1：

```
glBegin(GL_QUADS_STRIP);
    glVertex2iv(p1);
    glVertex2iv(p2);
    glVertex2iv(p4);
    glVertex2iv(p3);
    glVertex2iv(p5);
    glVertex2iv(p6);
    glVertex2iv(p8);
    glVertex2iv(p7);
glEnd();
```

## OpenGL的向量数组

如果按照上面所提到的这些函数依次绘制点、线、面，一个简单物体如六面体都需要上百个函数调用才能实现。一旦场景稍微复杂一点，所需操作就可能多到系统无法负荷。因此，OpenGL提供了一种降低函数调用的机制——**向量数组**（vertex array），其主要步骤为：  
1. 唤醒函数`glEnableClientState(GL_VERTEX_ARRAY)`  
2. 使用函数`glVertexPointer`来设定向量坐标的位置和数据形式  
3. 使用形如`glDrawElements`的函数来展示场景，该函数可以使用非常少的函数调用来实现多个图元绘制  
具体实现代码如下：

```
glEnableClientState(GL_VERTEX_ARRAY);
//第一个参数代表每个向量的维数，第三个参数代表相邻向量之间的字节偏移量（以供不同种类的数据可以打包到一个数组中，最后一个参数代表包括坐标值的向量数组）
glVertexPointer(3, GL_INT, 0, pt);

GLubyte vertIndex[] = (6, 2, 3, 7, 5, 1, 0, 4, 7, 3, 1, 5, 4, 0, 2, 6, 2, 0, 1, 3, 7, 5, 4, 6);

//第二个参数表示vertIndex中的元素个数
glDrawElements(GL_QUADS, 24, GL_UNSIGNED_BYTE, vertIndex);
```

## 像素数组图元

有bitmap和pixmap两种形式，会在下面详细说明

## OpenGL的像素数组函数

（**_这一节看的乱糟糟的，以后有时间再补充_**）

#### OpenGL的Bitmap函数

函数形式如下：

```
glBitmap(width, height, x0, y0, xOffset, yOffset, bitShape);
```

#### OpenGL的Pixmap函数

函数形式如下：

```
glDrawPixels(width, height, dataFormat, dataType, pixMap);
```

#### OpenGL的光栅操作

## 文字图元

两种“字体”的区别：  
- typeface：一系列文字的整体设计  
- font：特定大小和形式的某些字体

两种类型的字体：  
- 衬线体（serif）：在字的笔画开始、结束的地方有额外的装饰，而且笔画的粗细会有所不同。易识别。  
- 非衬线体（sans-serif）：没有这些额外的装饰，而且笔画的粗细差不多。比较醒目。

另外一种分类方式：  
- 单间隔（monospace）：所有字体宽度相同  
- 成比例（proportional）：字体的宽度会变化

计算机字体存储的两种方式：  
- 二进制字体（bitmap font）：用0、1存储，消耗存储空间大，字体变形（放大、缩小、加粗、倾斜等）时可能会发生形变  
- 空心字（outline font）：存储字体的内部和外部轮廓，消耗存储空间小，字体变形方便，但生成耗时较长

## OpenGL的文字函数

原生OpenGL不提供文字支持，需要glut包。下面是一个文字显示示例：

```
glRasterPosition2i(x,y);    //文字显示的世界坐标
for(k = 0; k < 36; k++)    //显示长度为36的字符串    
    glutBitmapCharacter(GLUT_BITMAP_9_BY_15, text[k]);
    //glutStrokeCharacter(font, character);用于显示空心字
```

## OpenGL展示列表

展示列表（display list）：将一个物体的描述（或任何其他的OpenGL命令）存储为一个被赋予名称的状态序列。示例如下：

```
const double TWO_PI = 6.2831853;

GLunit regHex;

GLdouble theta;
GLint x, y, k;

regHex = glGenLists(1);    //获取一个未使用过的listID
glNewList(regHex, GL_COMPILE);
    glBegin(GL_POLYGON);
        for(k = 0; k < 6; k++)
        {
            theta = TWO_PI * k / 6.0;
            x = 200 + 150 * cos(theta);
            y = 200 + 150 * sin(theta);
            glVertex2i(x, y);
        }
    glEnd();
glEndList();

//上面是List的创建，下面是List的执行
glCallList(regHex);
//下面是list的删除
//glDeleteLists(startID, nLists);————删除从startID开始的连续的nLists个list
```

注意：list中的各参数在初始化后就以值的方式存储在list中了，即对参数的外部修改不会影响list，也就是说list在创建后是不可修改的。

## OpenGL中改变展示窗口大小的函数

在程序的main函数中加入`glutReshapeFunc(winReshapeFcn);`即可，但是winReshapeFcn需要自己实现

## 基础知识

**Vertex（顶点）**

define the location of primitives in space, and consists of vertex stream.  
定义基元在空间中的位置，由顶点流组成。

顶点用于定义空间中基本图形（primitives）的位置。它包含了一个顶点流（vertex stream），通常这个顶点流包含了多个顶点。每个顶点包括了定义其在三维空间中位置的坐标信息，以及可能包括颜色、纹理坐标和法线等其他属性。

**Primitive**

1.  the result of the interpretation of a vertex stream, as part of Primitive Assembly 作为图元装配（Primitive Assembly）的一部分，图元是顶点流解释的结果。简单地说，图元是由顶点通过特定的规则连接起来形成的基本图形，如点、线和三角形。
    
2.  the interpretation scheme used by opengl to determine what a stream of vertices represents when being rendered. 在OpenGL中，图元也指定了如何解释顶点流来渲染。OpenGL根据定义的图元类型（例如点、线段、三角形）来决定如何将一连串的顶点组合成图形。
    

**Fragment**

a fragment is a collection of values produced by the Rasterization. Each fragment represents a sample-sized segment of a rasterized primitive. 片元是光栅化（Rasterization）过程产生的值的集合。每个片元代表了光栅化图元的**一个****样本大小**的部分。 片元包含了用于最终像素颜色计算的所有数据，比如颜色、深度以及其他可能的属性。在图形管线中，片元着色器（Fragment Shader）会处理这些片元，以生成最终在屏幕上显示的像素颜色。

## Graphics Pipeline

**There are three stages有三个阶段**

• Application Stage• 申请阶段

• Geometry Stage• 几何舞台

• Rasterization Stage

![](https://i-blog.csdnimg.cn/blog_migrate/e0e35a645b69b253f17b8b0523e4cd83.png)

![](https://i-blog.csdnimg.cn/blog_migrate/0af85b7b75988107ccf27e96d239d29c.png)

## Viewing process 视图处理过程

![](https://i-blog.csdnimg.cn/blog_migrate/d17621e840c7845b5d0db125c938237e.png)• Transform into **camera coordinates**.

• Perform projection into **view volume**.  
• 执行投影到**视图体积**。

• **Clip** geometry outside the view volume.  
• **剪切**视图体积块外的几何。

• Perform [Perspective](https://so.csdn.net/so/search?q=Perspective&spm=1001.2101.3001.7020)\-division into **NDC**.  
• 将 [Perspective](https://so.csdn.net/so/search?q=Perspective&spm=1001.2101.3001.7020) 划分为 **NDC**。

• **Remove** hidden surfaces  
• **移除**隐藏的曲面

Local space -> world space -> camera space -> clipping space -> NDC -> viewport  
本地空间 -> 世界空间 -> 摄像机空间 -> 裁剪空间 -> NDC -> 视口

### 1 Zooming1 缩放

Adjusting the **viewport** can implement zooming 调整视口大小和位置可以实现缩放功能。缩放时，你实际上是改变了最终图像在屏幕上显示的尺寸。

Adjusting the **clipping window** can implement broadening or shrinking what we see 调整裁剪窗口（即在裁剪空间中决定哪些部分是可见的）可以实现对可见场景的扩大或缩小，从而改变用户看到的场景范围。

### 2 View Volume

术语“view volume”（视图体积）和“clipping volume”（裁剪体积）通常可以视为相同的概念，在某些情况下可以互换使用。

![](https://i-blog.csdnimg.cn/blog_migrate/2f61abd27b92aa2f08f279d60cf64575.png)

#### 2.1 Orthographic view volume  
2.1 正交视图体积

• Preserves both distances and angles  
• 保留距离和角度

• Shapes preserved• 保留形状

• Can be used for measurements  
• 可用于测量

  • Building plans

  • Manuals

• Cannot see what object really looks like because many surfaces are hidden from view  
• 无法看到对象的真实外观，因为许多曲面都隐藏在视图中

• Often we add isometric

#### 2.2 Perspective view volume  
2.2 透视视图体积

• Objects further from viewer are projected smaller than the same sized objects closer to the viewer (diminution) • Looks realistic  
• 距离观察者较远的对象比距离观察者较近的相同大小的对象投影得更小（缩小）• 看起来更逼真

• Equal distances along a line are not projected into equal distances (nonuniform foreshortening)  
• 沿直线的相等距离不会投影为相等距离 （非均匀透视收缩）

• Angles preserved only in planes parallel to the projection plane  
• 仅在平行于投影平面的平面中保留角度

• More difficult to construct by hand than parallel projections (but not more difficult by computer)  
• 比平行投影更难手工构建（但不会更难用计算机）

### 3 Normalized Device coordinates (NDC)  
3 标准化设备坐标 （NDC）

### 4 Geometry vs Topology

geometry: **locations** of the vertices  
geometry：顶点**的位置**

topology: **organization** of the vertices and edges  
拓扑：**点**和边的组织

Topology holds even if geometry changes.  
即使几何图形发生更改，拓扑也保持不变。

## Solid modeling实体建模

Surfaced based & volume based

### 1 Surface based

#### 1.1 [Mesh](https://so.csdn.net/so/search?q=Mesh&spm=1001.2101.3001.7020) Based 边界表示（Boundary Representation, B-rep）

The size and shape is defined by the faces, edges and vertices which consists of its [boundary](https://so.csdn.net/so/search?q=boundary&spm=1001.2101.3001.7020).  
大小和形状由构成[其边界](https://so.csdn.net/so/search?q=boundary&spm=1001.2101.3001.7020)的面、边和顶点定义。

(low-dimensional elements)

• **Pros**: flexible and computers can render them quickly. The vast majority of 3D models today are built as textured polygonal models  
• **优点**：灵活，计算机可以快速渲染它们。如今，绝大多数 3D 模型都是作为带纹理的多边形模型构建的

• **Cons**: polygons are planar and need approximate curved surfaces using many polygons, representation is not unique  
• **缺点**：多边形是平面的，需要使用许多多边形的近似曲面，表示不唯一

很难闭合

#### ![](https://i-blog.csdnimg.cn/blog_migrate/bf36d34d03b9b9a7d38219edc2a24ddd.png)

#### 1.2 Constructive solid geometry(CSG) 构造实体几何  
1.2 构造实体几何

A solid is defined as the result of a sequence of regularized Boolean operations.  
实体被定义为一系列正则化布尔运算的结果。

• Pros: Computer-Aided Manufacturing: a brick with a hole drilled through it is represented as “just  
• 优点：计算机辅助制造：钻有孔的砖块表示为“只是

that” and CSG can easily assure that objects are “solid” or water-tight  
that“，并且 CSG 可以轻松确保对象是”固体“或水密的

• Cons: Relationships between objects might be very complex (search the entire tree) Real world objects may get very complex  
• 缺点：对象之间的关系可能非常复杂（搜索整个树） 现实世界的对象可能会变得非常复杂

![](https://i-blog.csdnimg.cn/blog_migrate/5a8e7428eec1e7911be30b29d1b5804e.png)

### 2 Volume based

Spatial decomposition: voxel octree BSP 体素（voxels）、八叉树（octree）和二叉空间分割（Binary Space Partitioning, BSP）等技术

#### 2.1 Voxels: a volume element

Pros:

• Modelling continues phenomena: medicine, geology, body, etc.  
• 建模延续现象：医学、地质、身体等。

• Regular data

• Easy to compute volume, make slices  
• 易于计算体积，制作切片

Cons:缺点：

• Massive data for high resolution

• The surface is always somehow “rough”  
• 表面总是以某种方式“粗糙”

### 3 Point based3 点制

#### 3.1 Point cloud

• Easily accessed with laser scanning, range camera or  
• 可通过激光扫描、测距摄像头或

stereo image matching立体图像匹配

• No connectivity

• Widely used!• 应用广泛！

## GLSL

### 1 Vertex shader

• Transform vertices

• Model, View and projection transformations  
• 模型、视图和投影转换

• Custom transformation

  • Morphing• 变形

  • Wave motion• 波浪运动

• Lighting

• Color

• Normal

• Other per-vertex properties

顶点着色器可以执行多种任务，比如变换顶点的位置、处理顶点的颜色和纹理坐标、计算光照等。

通常，它会将顶点从一个坐标系统转换到另一个坐标系统，例如从模型坐标转换到视图坐标。

### 2 Fragment shader

• Compute the color of a fragment/pixel  
• 计算片段/像素的颜色

• The input data is from rasterization and textures and other values  
• 输入数据来自栅格化和纹理以及其他值

确定每个片元的最终颜色和其他属性。这个过程可能包括纹理映射、光照和阴影计算、颜色混合等。

### 3 VAO VBO EBO

1.  VAO（顶点数组对象，Vertex Array Object）:
    
    1.  VAO是一个对象，它存储了所有的**顶点属性状态**（如顶点属性的布局）和与这些**属性相关的****VBO**。
        
    2.  使用VAO的目的是为了**保存顶点属性的配置和****数据源**。当配置顶点属性指针时，这些配置会存储在当前绑定的VAO中。
        
    3.  在渲染时，只需绑定相应的VAO，就可以使用其中的顶点属性配置和数据。
        
2.  VBO（顶点缓冲对象，Vertex Buffer Object）:
    
    1.  VBO用于在GPU内存中存储大量顶点的数据，如**顶点坐标、纹理坐标、法线、颜色**等。
        
    2.  VBO的使用可以大幅减少CPU到GPU的通信，提高渲染效率，因为顶点数据可以在渲染之前发送到GPU，然后在渲染时直接从GPU内存中获取。
        
    3.  在使用VBO时，顶点数据只需上传一次到GPU，之后可以多次用于渲染，这对于动画和复杂场景渲染非常有效。
        
3.  EBO（元素缓冲对象，Element Buffer Object）:
    
    1.  EBO也称为索引缓冲对象（Index Buffer Object），用于存储顶点**索引**。
        
    2.  使用EBO可以重用顶点数据，定义哪些顶点会组成一个图元（如三角形）。这样，相同的顶点可以被多次引用，减少了内存的使用和数据传输。
        
    3.  EBO通常与VBO一起使用，VBO存储顶点数据，EBO存储构成图元的顶点索引。
        

![](https://i-blog.csdnimg.cn/blog_migrate/29621151c23fc91fbba544ffa6eab1b6.png)

## 2D\_3D\_transformation

线性：Rotation, scale, shear, reflection are all **linear** but translation **is not linear**.  
线性：旋转、缩放、剪切、反射都是**线性**的，但平移**不是线性**的。

可交换：Only the same kinds of transformation are **commutative**.  
只有相同种类的转换是**可交换**的。

### ![](https://i-blog.csdnimg.cn/blog_migrate/e16955f778481f2eb82c45b9ed26f1d9.png)

### 1 Homogeneous coordinate 齐次坐标

Point refers that the last coordinate is 1  
Point 表示最后一个坐标为 1

Vector refers that the last coordinate is 0  
Vector 表示最后一个坐标为 0

\--> point - point = vector  
\--> 点 - 点 = 向量

### 2 Affine transformation 仿射变换

translation together with linear transformations  
平移与线性变换

Translation: Move dx, dy

![](https://i-blog.csdnimg.cn/blog_migrate/52b70bb851194d251aae3804ac0e4bba.png)

Rotation(counterclockwise)  
旋转（逆时针）

![](https://i-blog.csdnimg.cn/blog_migrate/79ebcab61ee48f9415512609ac4a328d.png)

Scale规模

![](https://i-blog.csdnimg.cn/blog_migrate/25632fc314fd0e3cbf78636538eb5fe2.png)

Rigid-motion: translation+rotation

### 3 Composite transformations  
3 复合变换

Rotate about a particular point : translate to the origin | rotate | translate back  
围绕特定点旋转 ： 平移到原点 |旋转 |翻译回来

Transformation of local coordinate systems---> obtain the coordinate in world space （以原先local coordinate原点为原点的世界系）  
局部坐标系的变换---> 获取世界空间中的坐标 （以原先局部坐标原点为原点的世界系）

𝑝𝑛 is the world coordinate of point p after n transformations  
PN 是 N 次变换后点 p 的世界坐标  
![](https://i-blog.csdnimg.cn/blog_migrate/de75a6f0b614c8667601c39c064b8cc9.png)

### 4 3D transformations

Translation

![](https://i-blog.csdnimg.cn/blog_migrate/c108892e37247868529c281c771c5655.png)

Scale规模

![](https://i-blog.csdnimg.cn/blog_migrate/a6e023ad852be42e748abe120604d132.png)

空间中的三维旋转（欧拉角的矩阵）四元数

## 2D\_3D\_viewing

![](https://i-blog.csdnimg.cn/blog_migrate/60d07182acfd867416bad7fc0f38f23f.png)

内侧的椭圆是“[Affine](https://so.csdn.net/so/search?q=Affine&spm=1001.2101.3001.7020)”（仿射），仿射变换是射影变换的一个子集，它保持了图形的平行性。仿射变换包括了“Similaritudes”（相似）和“Linear”（线性）变换。

“Similaritudes”椭圆进一步细分为“Rigid / Euclidean”（刚体或欧几里得）变换，这种变换包含了平移（Translation）、旋转（Rotation）和恒等（Identity）。这些变换保持了图形的形状和大小不变。

在“Linear”变换的范围内，有“Scaling”（缩放），“Reflection”（反射），“Shear”（剪切），以及“Isotropic Scaling”（等距缩放）。这些变换可以改变图形的大小，但可能会改变其形状。

“Perspective”（透视）在图的底部被提及，它通常关联于射影变换，但在这个图中没有被包含在任何椭圆内，这可能意味着它作为一个独立概念存在，涉及从特定视点观察物体时的变换。

The camera is located at origin and point in the -z direction.  
相机位于原点并指向 -z 方向。

### 1 The process of viewing  
1 观看过程

Transform into camera coordinate

\-> perform projection into view volume (orthogonal transformation/perspective transformation)  
\-> 执行投影到视图体积（正交变换/透视变换）

\-> clip geometry outside the clipping volume  
\-> 剪切体积之外的剪切几何图形

\-> project into screen coordinate(perspective division & viewport NDC)  
\->投影到屏幕坐标（透视划分和视口NDC）

\-> remove hidden surface

Model view matrix:

If we want to visualize objects with both positive and negative z values, we can move the camera in the positive z direction/ move the objects in the negative z direction.  
如果我们想同时可视化具有正 z 值和负 z 值的对象，我们可以沿正 z 方向移动相机/沿负 z 方向移动对象。

### 2 Projection transformation  
2 投影变换

#### 2.1 Orthogonal projection  
2.1 正交投影

![](https://i-blog.csdnimg.cn/blog_migrate/c6b448c156b0ebd88a8bbd4fb8e50ef7.png)

1.  Translation center to origin
    

T( -(left+right)/2 , -(bottom+top)/2 , (near+far)/2 )

1.  Scale to have sides of length 2  
    缩放边长为 2
    

S ( 2/(right-left) , 2/(top-bottom) , 2/(-far-(-near)) )

![](https://i-blog.csdnimg.cn/blog_migrate/e5837a941d0cb053be5312f3d7d3a988.png)Pay attention to left, right, bottom, top, -near, -far (the positive direction of z is outside the screen)  
注意 left， right， bottom， top， -near， -far （z 的正方向在屏幕外）

Final projection最终投影

![](https://i-blog.csdnimg.cn/blog_migrate/90f33c46ccebc2d3dac054fe0d73167a.png)

![](https://i-blog.csdnimg.cn/blog_migrate/a3dffc7ac68427ef9e73fddb54bf91a2.png)

#### 2.2 Perspective projection  
2.2 透视投影

![](https://i-blog.csdnimg.cn/blog_migrate/3511c43d4f54f68d05608b03833230f0.png)

Given the (xe,ye,ze) is coordinate in eye space. The coordinate of projection :  
给定 （xe，ye，ze） 是眼空间中的坐标。投影坐标 ：

![](https://i-blog.csdnimg.cn/blog_migrate/d10212d7d3916a304f96855efc05006b.png)

Then do the operation like orthogonal projection:  
然后像正交投影一样进行操作：

Translate and scale: n means normalize / c means clipping  
平移和缩放：n 表示标准化 / c 表示剪辑

![](https://i-blog.csdnimg.cn/blog_migrate/d9e5faa483ff468111938d132aa62241.png)

![](https://i-blog.csdnimg.cn/blog_migrate/df0137ffbafe8b1fa6dbc8ef31fdd21b.png)

![](https://i-blog.csdnimg.cn/blog_migrate/d323bf37b4fb327236066b118426a94c.png)

![](https://i-blog.csdnimg.cn/blog_migrate/0f08829365df06b92255dd1a700b62dd.png)

### 3 Clipping3 剪辑

![](https://i-blog.csdnimg.cn/blog_migrate/5a7711350c6704f71c2d07125943c807.png)

Perspective division could cause what should be clipped in clipping volume projected into NDC   
透视分割可能会导致在投影到 NDC 的剪切体积中应剪切的内容

#### 3.1 Why？3.1 为什么？

Avoid division by 0 && don’t draw things behind the eye  
避免除以 0 && 不要在眼睛后面画东西

Don’t waste time on objects outside the boundary.  
不要在边界外的对象上浪费时间。

![](https://i-blog.csdnimg.cn/blog_migrate/87fd408826ed4cc6d03138d1d230e7bd.png)

#### 3.2 Cohen-Sutherland Algorithm

![](https://i-blog.csdnimg.cn/blog_migrate/83296d80ddc11ea29abe6805961327ce.png)

The bit means up, down, right, left from left to right respectively.  
该位分别表示从左到右的上、下、右、左。

If the code of two endpoints is all 0000, it means the segment is in clipping window.  
如果两个端点的代码都是 0000，则表示该 Segment 处于剪辑窗口中。

If the result of intersecting the code of two endpoint concludes 1, it means the segment is out of clipping window.  
如果两个端点的代码相交的结果结束为 1，则表示该段超出剪辑窗口。

#### 3.3 Weiler-Atherton Clipping

多边形序列

裁剪窗口序列 逆时针进行排序

当在**多边形序列** or **裁剪窗口序列** 遍历到一个intersection时，转换到另一个序列继续遍历，若发现某点已经遍历，即绘制多边形。

当出现回路时，回退到最后一个existing intersection

其中entering intersection为进入点，existing intersection 为退出点

当多边形序列遍历完毕后，算法结束

![](https://i-blog.csdnimg.cn/blog_migrate/18cefcb2cc412131f06a17e5b622ea42.png)

#### 3.4 Sutherland-Hodgman Polygon Clipping  
3.4 Sutherland-Hodgman 多边形裁剪

(in,in) / (in,out) / (out,in)  
（in，in） / （in，out） / （out，in）

只要左边是in,一定输出一个点，且输出的点一定与右边数字有关，

Out,in 一定输出两个点，

Out out 输出None

![](https://i-blog.csdnimg.cn/blog_migrate/588131903378788d5e262fe58e796a37.png)

![](https://i-blog.csdnimg.cn/blog_migrate/e6a130b60984aa1010f7f167aa741b68.png)

## Visible surface detection  
可见表面检测

Visibility of primitives:  
基元的可见性：

primitive lies outside the field of the clipping volume  
Primitive 位于 Clipping Volume 的字段之外

Primitive is back-facing

Primitive is occluded by one or more objects nearer the viewer  
Primitive 被更靠近观察者的一个或多个对象遮挡

**Visible surface algorithms**

**Object space technique:**

applied before vertices are mapped to pixels  
在顶点映射到像素之前应用

Back face culling , painter’s algorithm, BSP tree  
背面剔除 、 painter 算法、BSP 树

**Image space technique:**

applied while the vertices are rasterized  
在栅格化顶点时应用

Z Buffer

### 1 Back face culling1 背面剔除

Face is visible iff θ∈\[-90,90\] culling faces --- should be hidden  
如果 θ∈\[-90,90\] 剔除应隐藏的人脸---则人脸可见

Equivalently cos >= 0 or v • n >= 0  
等效于 cos >= 0 或 v • n >= 0

### 2 Painter’s Algorithm

Render polygons a back to front order so that polygons behind others are simply painted over  
按从后到前的顺序渲染多边形，以便简单地覆盖其他多边形后面的多边形

### 3 BSP Tree (Binary space partitioning)  
3 BSP 树（二进制空间分区）

![](https://i-blog.csdnimg.cn/blog_migrate/07b0549669206768548fcd50551671a1.png)

Traverse the tree, remember that we should paint the point according to the distance sort.  
遍历树，记住我们应该根据距离排序来绘制点。

5a, 2, 1, 3, 5b, 4

### 4 Z-buffer complexity (n\*m\*k)

Rasterize every input polygon

Track depth values of closest polygon so far

Paint the pixel with the color of the polygon whose z value is the closest to the eye.  
使用 z 值最接近眼睛的多边形的颜色绘制像素。

**Advantage**

• Simple to implement in hardware.  
• 易于在硬件中实现。

• Memory for z-buffer is now not expensive  
• z 缓冲区的内存现在不昂贵

• Diversity of primitives – not just polygons.  
• 基元的多样性 - 不仅仅是多边形。

• Unlimited scene complexity  
• 无限的场景复杂性

• Don’t need to calculate object-object intersections.  
• 无需计算对象-对象交集。

**Disadvantage**

• Extra memory and bandwidth  
• 额外的内存和带宽

• Waste time drawing hidden objects  
• 浪费时间绘制隐藏对象

Z-precision errors

• May have to use point sampling  
• 可能必须使用点采样

Frame buffer to save color information, depth buffer to save minimal depth information  
帧缓冲区 保存颜色信息， 深度缓冲区 保存最小深度信息

When time to update the color, check whether current depth is less than saved depth.  
当需要更新颜色时，请检查当前深度是否小于保存的深度。

Z-buffer precision:（fighting）

Caused by the perspective division z/w when the interval is so small even come down to float-point precision.  
当间隔如此小时，由透视除法 z/w 引起，甚至归结为浮点精度。

push the zNear clipping plane out and pull the zFar plane in as much as possible  
将 zNear 剪切平面推出，并尽可能地拉入 zFar 平面

When far from projection plane, the resolution(分辨率) will enlarge, causing two closer primitive located in the same interval.  
当远离投影平面时，resolution（分辨率）将放大，导致两个更近的图元位于同一间隔内。

![](https://i-blog.csdnimg.cn/blog_migrate/1dfb41e054c87ea230a243668419df6c.png)

Rasterization
First job: enumerate the pixels covered by a primitive
第一个作业：枚举基元覆盖的像素

Second job: interpolate values across the primitive
第二项工作：跨原语插值

1 Points 1 积分
Inside + right-down point + right edge + down edge
内侧 + 右下点 + 右边缘 + 下边缘



2 Line
Given segment endpoints (x1,y1;x2,y2) are all integers
给定 segment 终端节点 （x1，y1;x2，y2）都是整数

下面开始展开

2.1 DDA（差分）


float point computation, round operation

2.2 Bresenham’s algorithm:


If a < b ,then upper pixel

If a > b, then lower pixe
如果 a > b，则降低像素







In order to avoid computing float point, multiple the Δx
为了避免计算浮点数，请将 Δx 乘以

2.3 Mid-point algorithm (0-45°)
Midpoint Circle Algorithm



公式：



递推公式：



3 Triangles 3 三角形
Draw edges vertically and fill in horizontal spans for each scan line
垂直绘制边缘并填充每条扫描线的水平跨度



4 Polygon
Inside or outside test:

Send a ray from that specific point,
从该特定点发送光线，

  if the intersections are odd---inner
如果交集为 odd---inner

  If the intersections are even ---- outer
如果交集甚至----外部

Pay attention the ray can’t touch a vertex or tangent with an edge.
请注意，光线不能接触具有边的顶点或切线。

Triangle method works only for convex ones
三角形方法仅适用于凸面

Polygon fill in:



When touching a vertex, with adjacent two edges on one size, the vertex should be viewed as two vertices.
当触摸一个顶点时，如果相邻的两条边的大小相同，则应将该顶点视为两个顶点。

5 Triangulation
Ear-clipping : 每次选取凸顶点从原图中删除，并生成三角形，直到最后只剩三个顶点为止



Trapezoid decomposition: 先划分为梯形，再按对角线分开为三角形



6 Interpolation
Attributes are interpolated during rasterization
在栅格化过程中对属性进行插值

• Depth

• Color

• Texture coords • 纹理坐标

• Many others • 许多其他



7 Anti-aliasing
• Basic idea: replace “is the image black at the pixel center?” with “how much is pixel covered by black?”
• 基本思路：将“图像的像素中心是否为黑色”替换为“黑色覆盖了多少像素？

• Replace yes/no question with quantitative question.
• 将 yes/no 问题替换为定量问题。



7.1 Box filtering
• Compute coverage fraction by counting subpixels
• 通过计算子像素来计算覆盖率

• Simple, accurate • 简单、准确

• Slow

• Unweighted filtering • 未加权过滤



7.2 Weighted filtering 7.2 加权过滤
• Compute filtering integral by summing filter values for covered subpixels
• 通过对覆盖的子像素的过滤器值求和来计算过滤积分

• Simple, accurate • 简单、准确

• But really slow • 但真的很慢

### Light Science
Light color vs reflected color:
光色与反射色：

The resulting color of the object is light color and multiply the reflected color.
对象的结果颜色是浅色，并乘以反射的颜色。

1 Visual cues to 3D geometry
• size (perspective) • 大小 （透视图）

• occlusion (depth)

• shading

Light color vs reflected color:
光色与反射色：

The resulting color of the object is light color and multiply the reflected color.
对象的结果颜色是浅色，并乘以反射的颜色。

2 Illumination model （compare）
• Global illumination model

        • Simulate not only the direct illuminations but also the indirect illuminations
• 不仅模拟直接照明，还模拟间接照明

• Ray-tracing

• Radiosity

• Photon Mapping • 光子映射

• Can handle • 可以处理

        • Reflection (one object in another)
• 反射 （一个对象在另一个对象中）

        • Refraction (Snell’s Law)
• 折射（斯涅尔定律）

        • Shadows

        • Color bleeding

• More computation and slow
• 计算量多，速度慢

• Local illumination model

        • Considers light sources and surface properties only
• 仅考虑光源和表面特性

• Gouraud shading

• Phong shading

• Shadow techniques • 阴影技术

• Can approximate GI! • 可以近似 GI！

        • Environmental Mapping

        • Ambient occlusion • 环境光遮蔽

        • Image based lighting

• Fast and real-time • 快速和实时

• Not as accurate as GI
• 不如 GI 准确

3 Local illumination model
• Light sources

• Geometry

• Material

• Viewing Direction • 观看方向

4 Light Sources

#### 光分类
- Point light
	- (a0,a1,a2) means coefficient for attenuation（a0，a1，a2） 表示衰减系数，根据distance(distance的函数)确定强度衰减值
- Directional light(平行光--太阳光)
	- Directional light has no attenuation because of the infinite distance.由于距离无限远，平行光没有衰减。

-  Spotlight聚光灯
	- 单位向量点击小于cosθ，即角度大于θ（0<θ<90)
	- 使用α来表示一个平缓变换的情况
- 面光源
- 体积光源

#### Phone reflection model (empirical model)
- Ambient + diffuse + specular
- 环境光 + 漫反射 + 镜面反射
- 输入
	- 材料属性
	- I: vector to light source矢量到光源
	- n: surface normal n：表面法线
	- v: vector to viewer v：查看器的方向矢量
	- r: reflection of Lat P (determined by I and n)
		- r：L在 P 处的反射（由 L的I 和 n 决定）
- 环境光
	- 不同的表面可以有不同的环境反射系数 k（0 ≤ k≤ 1），因此，如果只考虑环境照明，则某一点的照度仅为 I= L* k
- 漫反射
	- 兰伯特定律
	- 强度取决于入射光的角度：光线与表面法线的夹角
	- 假设所有方向均等
	- $I_d=k_d*cos \theta *L（\theta<90)$
	- $I_d=0（\theta大于90）$
- 镜面反射
	- ·Shiny surfaces have high specular coefficient光亮表面具有高镜面反射系数
	- The higher α is , the narrower specular lightα越高，镜面反射光越窄（由材质决定）
	-  $Is = max(k_s L_s cos^αϕ, 0.0)$
	- cosϕ = r 与v的夹角
- summary：$I = L_ak_a + L_dk_d max(cos(l 与 n的夹角 ),0) + L_sk_smax(cos^α(r与 v的夹角) , 0)$
#### Blinn-Phone reflection model

Use calculating a halfway vector between the viewer and light-source vectors to instead computing the dot product of r and v
使用计算查看器和光源向量之间的中间向量来计算 r 和 v 的点积

-> the cost of computing reflecting vector is more than computing halfway vector
-> 计算反射向量的成本高于计算一半向量的成本

In addition, the angle of the Blinn-Phone model is smaller than the Phone model, which makes the specular look more natural.
此外，Blinn-Phone 模型的角度比 Phone 模型小，这使得镜面反射看起来更自然。

7 Flat shading
All pixels inside each polygon have the same color. --- fast
每个多边形内的所有像素都具有相同的颜色。---快

Good for polyhedral objects but not good for smooth surfaces.
适用于多面体对象，但不适用于光滑表面。



8 Gourand shading
An interpolation method.

Step:

Normal average vector (获取每个顶点邻接面的法向量的平均值作为每个顶点的法向量)

Vertex-lightening (based on illumination model)

Bilinear interpolation (for color) 双线性插值

Not good at highlight



9 Phone shading
An interpolation method.

Phong shading interpolates normals rather than colors
Phong 着色插值法线而不是颜色

interpolates surface normal across rasterized polygons and computes pixel colors based on the interpolated normal
跨栅格化多边形插值表面法线，并根据插值法线计算像素颜色

Computationally expensive but could capture the highlight
计算成本高昂，但可以捕获高光

At each pixel, n is recomputed and normalized
在每个像素处，n 被重新计算和归一化

Then l is computed at each pixel (lighting model is more expensive than interpolation algorithms)
然后计算每个像素的 l （照明模型比插值算法更昂贵）

Texture mapping 纹理映射
An image is pasted onto the 3D model, which is called a texture map.
将图像粘贴到 3D 模型上，这称为纹理映射。

1 Use of texture mapping
1 纹理映射的使用
• Describe surface material properties
• 描述表面材料属性

• Normal and Displacement
• 法向和位移

• Precomputed lighting and shadows

2 Texture vs material
Material is the intrinsic properties of a surface defining how lighting interacts with the surface
Material 是表面的固有属性，定义照明如何与表面交互

Texture is an “image-based” data describing appearance property
纹理是描述外观属性的“基于图像”的数据

Texture mapping is a part of rasterization
纹理映射是栅格化的一部分

3 Surface texture mapping:
3 表面粗糙度贴图：


Two mapping functions: 两个映射函数：

Find the mapping relation between texture coordinate and uv coordinate:
求 texture coordinate 和 uv coordinate 之间的映射关系：



Find the mapping relation between uv coordinate and object coordinate:
求 uv 坐标和物体坐标之间的映射关系：



UV coordinate is the transition between texture coordinate and object coordinate.
UV 坐标是纹理坐标和对象坐标之间的过渡。

Finding the true color via uv coordinate
通过 uv 坐标查找真彩色

Backward mapping: 反向贴图，通过obj模型和相应的映射关系，将模型上的贴图展成纹理图片

3.1 UV Interpolation
(texture coordinate <--> uv coordinate)

In screen space can not use linear interpolation .
在屏幕空间中不能使用 线性插值 。



线性插值是基于仿射变换的，在屏幕坐标系中产生两个三角形的仿射变换不相同，而在UV坐标系中两个三角形是相同的，导致了映射函数虽然连续但不平滑（导数不连续）

(u,v) should be divided by the depth
（u，v） 应除以深度



3.2 UV Mapping
Mesh parameterization

(uv coordinate <--> object coordinate)

Orthogonal mapping 正交映射

Cylindrical mapping: 圆柱形映射：

柱面坐标系:



Linear relation between (u,v) and (s,t)
（u，v） 和 （s，t） 之间的线性关系

When u=0, s=0; u=2Π,s=1;

When v=0, t=0; v=h, t=1;
当 v=0 时，t=0;v=h， t=1;



Spherical mapping: 球形映射：

球面坐标系：



4 Aliasing of textures
当许多纹理点被包含在同一像素中或纹理表面的分辨率过高时，会产生

4.1 Texture prefiltering
we can pre-compute the averages (once) and just look up these averages (many times) at run-time
我们可以预先计算平均值（一次），然后在运行时（多次）查找这些平均值

4.2 Mipmapping
根据一个像素中包含的纹理数量来切换分辨率

• Use a texture of multiple resolutions
• 使用多个分辨率的纹理

• Switch the resolution according to the number of texels in one pixel
• 根据一个像素中的纹素数量切换分辨率

防止jump：

Rather than clamping the Mipmap level to the closest integer, interpolating between levels
而不是将 Mipmap 级别固定到最接近的整数，而是在级别之间进行插值

三线性插值

5 Other mapping 5 其他映射
5.1 Bump mapping 5.1 凹凸贴图
Use texture to disturb the normal. (the visual illusion, shadow is very smooth)
使用 texture 来干扰法线。（视觉错觉，阴影很平滑）

5.2 Displacement mapping 5.2 位移映射
Use the texture map to actually move the surface point
使用纹理贴图实际移动曲面点

5.3 Environment mapping 5.3 环境映射
simulate the reflection using texture mapping!
使用 Texture Map 模拟反射！

5.4 Cubic mapping 5.4 三次方映射
2D UV coordinates becomes 3D texture directions



Physically-based Rendering（新增，极易考到）
1 Equation


2 BRDF
BRDF是指双向反射分布函数（Bidirectional Reflectance Distribution Function）的缩写，是用于描述材料表面反射特性的函数。它描述了入射光线与出射光线之间的关系，包括反射角度、入射角度和光线波长等因素。

Encodes behavior of light that “bounces off” surface
编码“从”表面反射的光线的行为





3 Transmission
• In addition to reflecting off surface, light may be transmitted through surface.
• 除了从表面反射外，光还可能通过表面透射。

• Light refracts when it enters a new medium
• 光进入新介质时发生折射

• BTDF (Bidirectional transmittance distribution function)

Law of refraction: Snell’s Law
折射定律：斯涅尔定律

Law of reflection: Fresnel's Law
反射定律：菲涅耳定律

4 Randiance and Irradiance
4 Randiance 和 Irradiance
Radiance is the solid angle density of irradiance 辐射度是辐照度的立体角密度







辐射度（Radiance）：

定义：辐射度是指从某一方向上单位立体角内，传递通过单位面积的光能量。它是一个方向性的量，不仅取决于光的强度，还取决于光的传播方向。

数学表达：通常用 L 表示，其单位是瓦特每平方米每球面度。

应用：辐射度在渲染方程中非常重要，用于计算从光源到观察者的光线强度，包括考虑物体表面的反射、吸收和散射等。

辐照度（Irradiance）：

定义：辐照度是指单位面积上接收到的光能量，它描述了光源对物体表面的照射强度。

数学表达：通常用 E 表示，其单位是瓦特每平方米。

应用：辐照度用于计算物体表面由于光照而接收到的能量，是光照模型（如Phong光照模型）中的一个关键组成部分。

划重点
• What 3D clues do you know until now? （上文）
• 到目前为止，您知道哪些 3D 线索？（上文）

• How many types of light sources do you know? （上文）
• 您知道多少种光源？（上文）

• Reflection model vs Shading method?

• Why blinn phong is better than phong （上文）
• 为什么 blinn phong 比 phong 好 （上文）

• Why phong shading is better than gourand shading? （插值的对象）
• 为什么 phong 阴影比 gourand 阴影更好？（插值的对象）

• Material vs Texture? （上文）

• How to deal with multiple light sources simultaneously?
• 如何同时处理多个光源？

• How does the number of lights affect performance?
• 灯的数量如何影响性能？



• How to rasterize an arbitrary polygon? （上文，扫描法）
• 如何栅格化任意多边形？（上文，扫描法）

• Mipmapping vs Bump mapping vs Displacement mapping vs Cubic mapping?
• Mipmapping vs Bump mapping vs Displacement mapping vs Cubic映射？

• The flexible usages of texture objects? （usage 上文）
• 纹理对象的灵活使用？（usage 上文）

• Shadow map vs Shadow volume? 

• What is the definition of radiance and irradiance?
• 辐射度和辐照度的定义是什么？

• What is the rendering equation?
• 什么是渲染方程式？

• What is BRDF  • 什么是 BRDF
