# 正则表达式
## 习题 3.1.1
写出表示下列语言的正则表达式：
- a) 字母表 {𝑎, 𝑏, 𝑐} 上包含至少一个 𝑎和至少一个 𝑏 的串的集合。
	- $(a+b+c)^*a(a+b+c)^*b(a+b+c)^*+(a+b+c)^*b(a+b+c)^*a(a+b+c)^*$
- b) 倒数第 10 个符号是 1 的 0 和 1 的串的集合。
	- $(1+0)^*1(1+0)^9$
- c) 至多只有一对连续 1 的 0 和 1 的串的集合。
	- $(10+0)^*(1+11+ε)(01+0)^*$
## 习题 3.1.3
写出表示下列语言的正则表达式：
- a) 不包含 101 作为子串的所有 0 和 1 的串的集合。
	- $0^*(1+000^*)^*0^*$
- b) 具有相同个数的 0 和 1，使得在任何前缀中，0 的个数不比 1 的个数多 2，1 的个数也不比 0 的个数多 2，所有这种 0 和 1 的串的集合。
	- $(01+10)^*$
- c) 0 的个数被 5 整除且 1 的个数是偶数的所有 0 和 1 的串的集合。
	- `(00000+11+(01+10)(11)*10000+(001+(01+10)(11)*(0+101))(11)*1000+(0001+(01+10)(11)*1001+(001+(01+10)(11)*(0+101))(11)*(0+101))(11)*100+(00001+(01+10)(11)*10001+(001+(01+10)(11)*(0+101))(11)*1001+(0001+(01+10)(11)*1001+(001+(01+10)(11)*(0+101))(11)*(0+101))(11)*(0+101))(11+00(11)*10001+00(11)*(0+101)(11)*1001+(00(11)*1001+00(11)*(0+101)(11)*(0+101))(11)*(0+101))*(10+01+00(11)*10000+00(11)*(0+101)(11)*1000+(00(11)*1001+00(11)*(0+101)(11)*(0+101))(11)*100))*`

## 习题3.1.4
给出下列正则表达式语言的自然语言描述：
- a) $(1 + ε)(00^∗1)^∗0^∗$。
	- 不包含连续的 1 的 0 和 1 的串的集合
- b) $(0^∗1^∗)^∗000(0 + 1)^∗$。
	- 存在三个连续的 0 的所有 0 和 1 的串的集合
- c) $(0 + 10)^∗1^∗$。
	- 除了字符串末尾外不包含连续的 1 的 0 和 1 的串的集合
## 习题3.2.4
把下列正则表达式转化成带 𝜀 转移的 NFA．
- a) $01^∗$。
![[Pasted image 20241031220227.png]]
- b) (0 + 1)01。
![[Pasted image 20241031221158.png]]
- c) $00(0 + 1)^∗$。
![[Pasted image 20241031221500.png]]
## 习题3.2.8
给出一个算法：输入一个 DFA 𝐴，对于给定的 𝑛（与 𝐴 的状态个数无关），计算出 𝐴 所接受的长度为 𝑛 的串的个数。这个算法应当对于 𝑛 和 𝐴 的状态数来说都是多项式的。提示：使用定理 3.4 的构造所提示的技术。
假设$N^{(k)}_{ijl}$为从状态i到状态j 的长度为l的路径数，且该路径不经过编号大于k 的状态。

 \( k = 0 \) 有如下表达式：

$$
N_{ijl}^0 = 
\begin{cases} 
0 & \text{if } i = j, l \geq 1 \\
1 & \text{if } i = j, l = 0 \\
\text{i 到 j 的路径数} & \text{if } i \neq j 
\end{cases}
$$


假设存在从 \( i \) 到 \( j \) 的路径不经过比 \( k \) 高的状态。有两种可能的情形需要考虑。

1. 这条路径根本不经过 \( k \) 状态。

2. 这条路径经过状态 \( k \) 至少一次。把路径分成几段，第一段不经过 \( k \) 而从状态 \( i \) 到状态 \( k \)，最后一段不经过 \( k \) 而从 \( k \) 到 \( j \)，所有中间路段都不经过 \( k \) 而从 \( k \) 到自身。这部分字符串的个数可以表示为：

$$
\sum N_{ikl_1}^{(k-1)} \cdot N_{kkl_2}^{(k-1)} \cdots N_{kkl_{n-1}}^{(k-1)} \cdot N_{kjl_n}^{(k-1)}
$$

因此结合前两种情况有表达式：

$$
N_{ijl}^{(k)} = N_{ijl}^{(k-1)} + \sum N_{ikl_1}^{(k-1)} \cdot N_{kkl_2}^{(k-1)} \cdot \cdots \cdot N_{kkl_{n-1}}^{(k-1)} \cdot N_{kjl_n}^{(k-1)}
$$
由题意，对 DFA 𝐴 所接受的长度为 𝑛 的串的个数可以表示为：
$\sum_j N_{1jn}^{(s)}$,
其中，s 表示 DFA 的总状态数，1 为起始状态，j 为任意的接收状态。

## 习题3.3.1
给出一个正则表达式，来描述所能想到的所有不同形式的电话号码。考虑国际号码以及不同国家有不同位数的区号和本地电话号码。
1) 以中国大陆为例的国内电话号码格式如下：长途冠码 + 省市区号 + 电话号码
	- 长途冠码：在国内拨打长途需加拨长途冠码“0”；
	- 省市区号：不同省、直辖市、大型城市分配的代号，比如北京市为“10”
	- `(0\d{2,3})[-.\s]?1\d{10}`
![[Pasted image 20241031215029.png]]
- `(0\d{2,3})`：长途冠码和省市区号部分。
    - `0`：国内长途冠码，以“0”开头。
    - `\d{2,3}`：省市区号，2到3位数字（例如，北京市的“10”，上海市的“21”，或广东省的“020”）。
- `[-.\s]?`：可选的分隔符，用于分隔区号和号码，可以是空格、点或连字符。
- `1\d{10}`：电话号码，1开头的共11位数字。
1) 国际号码的电话格式如下：国际冠码 + 国际电话区号 + 电话号码
	- 国际冠码：不同国家有不同的国际冠码（中国大陆是“00”），拨打国际电话的时候要根据拨出地区确定国际冠码，但可以统一用“+”表示；
	- 国际电话区号：每个国家分配的一个代码，中国大陆为“86”；
	- `\+?([0-9]( |-)?){6,15}[0-9]`
![[Pasted image 20241031215515.png]]




